This file is to record things I try to figure out how gem5 works. 
09-03-2014

Connect ports to CPU
src/cpu/BaseCPU.py
connectAllPorts
addPrivateSplitL1Caches()

09-02-2014
All the objects are instatiated in function instatiate() in
src/python/m5/simulate.py
*The structure is instantiated starting from the root instance and descending
along the SimObject children

Add GooUnit:

1. Create a GooUnit.py in src/cpu/o3
2. Create a goounit.cc in src/cpu/o3; with create() function
3. Declare in goounit.hh file
4. Instantiate a GooUnit object in configs/example/se.py
   when initialize System
5. Adapt src/cpu/o3/Sconscript
6. Adapt src/sim/system.cc to get a reference on the new unit
7. Adapt src/sim/system.hh
8. Adapt src/sim/System.py

08-25-2014

Add debugging flag:
If you find that events of interest are not being traced, feel free to add
DPRINTFs yourself. You can add new debug flags simply by adding TraceFlag()
command to any SConscript file (preferably the one nearest where you are using
the new flag). If you use a debug flag in a C++ source file, you would need to
include the header file "debug/<name of debug flag>.hh" in that file.

08-19-2014

initVirtMem
=>src/sim/process.hh/cc
=>X86_64LiveProcess::initState()=>src/arch/x86/process.hh/cc
==>Process::initState() => src/sim/process.cc
===>tc->activate() => src/cpu/o3/thread_context_impl.hh
====> activateContext() -> activateThread(): src/cpu/o3/cpu.cc
==>initVirtmem.writeBlob()
====>src/mem/se_translating_port_proxy.cc
=====>(src/mem/port_proxy.cc/hh)
=====>blobHelper()
======>_port.sendFunctional(&pkt);

bypassCaches()
08-18-2014
get compatible x86 assembily code:
objdump -M intel intel-mnemonic -D aes > aes.s

error now:
load value is 0->needs real value


inst executing process: 
src/cpu/o3/iwe_impl.hh
if (inst->isMemRef())
{
  if (inst->isLoad())
    fault = ldstQueue.executeLoad(inst);
  else if (inst->isStore())
    fault = ldstQueue.executeStore(inst);
}
else
{
  inst->setExecuted();
  instToCommit(inst);
}

src/cpu/o3/lsq_unit_impl.hh
executeLoad and executeStore
=>inst->initiateAcc()

executeLoad()
=> src/cpu/o3/lsq_unit_impl.hh
load_fault = inst->initiateAcc() //initiate memory access
writeback()
{
  inst->completeAcc(pkt);
}
=>src/cpu/o3/dyn_inst.hh
=>src/cpu/o3/dyn_inst_impl.hh
=>src/cpu/base_dyn_inst.hh
=>src/cpu/static_inst.hh

08-15-2014

#things I did to get a perfect cache:
1. src/mem/cache/BaseCache.py
add: is_perfect_cache = Param.Bool(False, "is this cache perfect (e.g. always hit)")
2. src/mem/cache/base.hh
add: const bool isPerfectCache;
3. src/mem/cache/base.cc
add in BaseCache constructor:
isPerfectCache(p->is_perfect_cache),
4. src/mem/cache_impl.hh
inside function Cache::access()
add:
if (isPerfectCache)
{

}
does not work...
change to:

  if (blk != NULL) {

    if (pkt->needsExclusive() ? blk->isWritable() : blk->isReadable()) {
      // OK to satisfy access
      incHitCount(pkt);
      satisfyCpuSideRequest(pkt, blk);
      return true;
    }
  }
  else if (isPerfectCache)
  {
    incHitCount(pkt);
    lat = hitLatency;
    blk = allocateBlock(pkt->getAddr(), writebacks);
    tags->insertBlock(pkt, blk);
    blk->status = BlkValid | BlkReadable;
    satisfyCpuSideRequest(pkt, blk);
    DPRINTF(Cache, "%s new state is %s\n", __func__, blk->print());
    return true;
  }

5. build/X86/params/BaseCache.hh
add bool is_perfect_cache;

6. src/mem/cache/tags/Tags.py
add: 
is_perfect_cache = Param.Bool(Parent.is_perfect_cache, "Is this cache perfect (e.g. always hit)")

7. src/mem/cache/tags/base.hh
add:
const bool isPerfectCache;

8. src/mem/cache/blk.hh 
add function:
void setStatus(state input)
{}

sn: instruction sequence number (dynamic instruction id)
src/cpu/base_dyn_inst.hh
BaseDynInst:

error msg: system.cpu.commit: Inst [sn:1] PC () has a fault. 
=>src/cpu/o3/commit_impl.hh 
Fault inst_fault = head_inst->getFault();

error msg: system.cpu.iew.lsq.thread0: Load [sn:1] not executed from fault
=>src/cpu/o3/lsq_unit_impl.hh
load_fault = inst->initiateAcc()
=>src/cpu/o3/dyn_inst.hh
=>src/cpu/o3/dyn_inst_impl.hh

src/arch/x86/isa/microops/ldstop.isa
fault = readMemTiming()
=>src/arch/x86/memhelpers.hh
return xc->readMem()
=>src/cpu/base_dyn_inst.hh
=>initiateTranslation(in the same file)
==>cpu->dtb->translateTiming() 
===>src/arch/x86/tlb.cc
===>TLB:translate()
=>fault = cpu->read()
==>forwards read to LSQ (src/cpu/o3/cpu.hh)
===>iew.ldstQueue.read()
===>src/cpu/o3/lsq.hh =>lsq_unit.hh

Request
=>src/mem/request.hh

=>src/cpu/checker/cpu.cc
src/sim/fault_fwd.hh
Fault: RefCountingPtr<FaultBase>
RefCountingPtr=>src/base/refcnt.hh
FaultBase=>src/sim/faults.hh

faults:
src/arch/x86/faults.hh


Cache related debugging flags:
Cache,CachePort,CacheRepl,CacheTags,TLB

adding l1d/i/2_hit_latency into Options.py and CacheConfig.py

modify cache replacement policy: files to check
src/mem/cache/base.cc (at the bottom)
src/mem/cache/tags/Tags.py 
src/mem/cache/BaseCache.py ?

and use configs/common/Caches.py 

forexample, 
class L1Cache(BaseCache):
  tags = LRU()

(can use python eval() function to set in the config options.py)


08-14-2014
src/mem/cache/cache_impl.hh
access()
cache replacement policy:
src/mem/cache/tags/fa_lru.hh
src/mem/cache/tags/lru.hh


no TLB delay model added:
http://www.mail-archive.com/gem5-users@gem5.org/msg09823.html

monitoring:
http://www.mail-archive.com/gem5-users@gem5.org/msg09221.html

src/cpu/o3: lsq_unit.hh
read():
 dcachePort->sendTimingReq
08-12-2014

allocate physical pages:src/sim/system.cc
allocPhysPages(int npages) -- always continues

Supported SE CPU Types:

             | Alpha | ARM | MIPS | POWER | SPARC | x86 | 
SimpleAtomic |   Y   |  Y  |  Y   |   Y   |   Y   |  Y  |
SimpleTiming |   Y   |  Y  |  Y   |   Y   |   Y   |  Y  |
In-Order     |   Y   |  N  |  Y   |   N   |   N   |  N  |
Out-of-Order |   Y   |  Y  |  Y   |   Y   |   Y   |  Y  |

             | Alpha | ARM | MIPS | POWER | SPARC | x86 | 
vtophys      |   Y   |  Y  |  N   |   N   |   Y   |  Y  |
(src/arch/
*/vtophys.cc)

Useful flags (and their default values):
--list-cpu-types
--cpu-type=atomic //detailed:out-of-order model
--caches //required for out-of-order model
--l2cache 
--mem-type=simple_mem  //mem aliase there
--mem-channels=1
--mem-size=512MB
--num-dirs=1
--num-l2caches=1
--num-l3caches=1
--l1d_size=64KB
--l1i_size=32KB
--l2_size=2MB
--l3_size=16MB
--l1d_assoc=2
--l1i_assoc=2
--l2_assoc=8
--l3_assoc=16
--cacheline_size=64

--sys-voltage=1.0V
--sys-clock=1GHz
--cpu-clock=2GHz

--output=OUTPUT  //redirect stdout
--errout=ERROUT  //redirect stderr


configs/common/Caches.py

L1Cache:
assoc=2
hit_latency = 2
response_latency = 2
mshrs = 4
tgts_per_mshr = 20
is_top_level = True

L2Cache:
assoc=8
hit_latency = 20
response_latency = 20
mshrs = 20
tgts_per_mshr = 12
write_buffers = 8

IOCache: 
assoc = 8
hit_latency = 50
response_latency = 50
mshrs = 20
size = 1kB
tgts_per_mshr = 12
forward_snoops = False
is_top_level = True

PageTableWalkerCache
assoc = 2
hit_latency = 2
response_latency = 2
mshrs = 10
size = 1kB
tgts_per_mshr = 12
is_top_level = True

src/arch/x86/X86TLB.py
TLB size: 64
Number of outstanding walks that can be squashed per cycle: 4

src/arch/x86/isa_traits.hh
VMPageSize = 1 << 12 = 4KB

src/cpu/o3/O3CPU.py (default parameters for O3CPU)
fetchWidth = 8
fetchBufferSize = 64
decodeWidth=8
renameWidth=8
dispatchWidth=8
issueWidth=8
wbWidth=8
commitWidth=8
LQEntries = 32
SQEntries = 32
numRobs = 1
numPhysIntRegs = 256
numPhysFloatRegs = 256
numIQEntries = 64
numROBEntries = Param.Unsigned(192, "Number of reorder buffer entries);

src/cpu/o3/O3CPU.py (default parameters for O3CPU)
IntALU: count=6
IntMultDiv: count=2
*IntMult: opLat = 3
*IntDiv: opLat = 20, issueLat=19
FP_ALU: count=4
*FloatAdd: opLat = 2
*FloatCmp: opLat = 2
*FloatCvt: opLat = 2
FP_MulDiv: count = 2
*FloatMult, opLat = 2
*FloatDiv, opLat = 12, issueLat = 12
*FloatSqrt, opLat = 24, issueLat = 24
SIMD_Unit: count = 4
ReadPort: count = 0
WritePort: count = 0
RdWrPort: count = 4
IprPort: count = 1, opLat = 3, issueLat = 3

src/mem/SimpleMemory.py
SimpleMemory: latency=30ns, bandwidth=12.8GB/s

configs/common/FuncUnitConfig.py
l2 and tol2bus is the same clock frequency as the core
L1-to-L2 bus width = 32 Bytes (256 bits)

to compile MachSuite for gem5/POWER
gcc -static -m32 

config/common/Simulation.py
benchCheckpoints: 
=>m5.simulate()
=>src/python/m5/simulate.py
=>internal.event.simulate()

=>src/sim/simulate.cc


common/example/se.py
cpu_type: atomic (AtomicSimpleCPU)
mem_type: simple_mem (SimpleMemory)

src/sim/system.cc
Class System

config/common/CpuConfig.py

CPU Classes: 
arm_detailed
AtomicSimpleCPU: Simple CPU model executing a configurable number of
instructions per cycle. This model uses the simplified 'atomic' memory mode. 
DerivO3CPU
TimingSimpleCPU

CPU Aliases:
timing => TimingSimpleCPU
detailed => DerivO3CPU
atomic => AtomicSimpleCPU

config/common/MemConfig.py

Mem Classes: 
LPDDR2_S4_1066_x32
LPDDR3_1600_x32
WideIO_200_x128
DDR3_1600_x64
SimpleMemory
SimpleDRAM

Mem aliases:
lpddr3_1600_x32 -> LPDDR3_1600_x32
lpddr2_s4_1066)x32 => LPDDR2_S4_1066)x32
DDR3_1600_x64 => DDR3_1600_x64
WIO_200_x128 => WideIO_200_x128
simple_mem => SimpleMemory



08-11-2014
1. To compile gem5
It's a relatively staightforward process if you set up all the 
dependences. One of the biggest issue I run into is missing stddef.h for newer
version of gcc. I fixed that by modifying src/python/m5/params.py and
SimObject.py. 

Adding the following lines after "code('%module(package="m5.internal") ${{self.swig_module_name()}}')"

        code('''\
/**
  * This is a workaround for bug in swig. Prior to gcc 4.6.1 the STL
  * headers like vector, string, etc. used to automatically pull in
  * the cstddef header but starting with gcc 4.6.1 they no longer do.
  * This leads to swig generated a file that does not compile so we
  * explicitly include cstddef. Additionally, including version 2.0.4,
  * swig uses ptrdiff_t without the std:: namespace prefix which is
  * required with gcc 4.6.1. We explicitly provide access to it.
  */
#include <cstddef>
#include <stddef.h>
using std::ptrdiff_t;
''')
        code('%}')

2. debug flags
gem5 takes debug flags, to see all the flags:
./gem5.opt --debug-help

to enable specific flags, e.g., Decode and Decoder,

./gem5.opt --debug-flags=Decode,Decoder

3. Useful wiki links
http://www.gem5.org/docs/html/gem5MemorySystem.html
