#!/usr/bin/env python
# CortexSuite benchmark definitions

from design_sweep_types import *

disparity = Benchmark("disparity", "disparity/src/c/script_disparity")
disparity.set_kernels(["computeSAD", "integralImage2D2D",
                       "finalSAD", "findDisparity"])
disparity.add_loop("computeSAD", 16, UNROLL_ONE)
disparity.add_loop("computeSAD", 18)
disparity.add_loop("integralImage2D2D", 16)
disparity.add_loop("integralImage2D2D", 19, UNROLL_ONE)
disparity.add_loop("integralImage2D2D", 20)
disparity.add_loop("integralImage2D2D", 25, UNROLL_ONE)
disparity.add_loop("integralImage2D2D", 26)
disparity.add_loop("finalSAD", 18, UNROLL_ONE)
disparity.add_loop("finalSAD", 20)
disparity.add_loop("findDisparity", 16, UNROLL_ONE)
disparity.add_loop("findDisparity", 18)
disparity.add_array("Ileft", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("Iright_moved", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("SAD", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("SAD", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("integralImg", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("Ileft", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("Iright_moved", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("SAD", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("integralImg", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("retSAD", 12290, 4, PARTITION_CYCLIC)
disparity.add_array("integralImg", 12742, 4, PARTITION_CYCLIC)
disparity.add_array("retSAD", 12290, 4, PARTITION_CYCLIC)
disparity.add_array("retSAD", 12290, 4, PARTITION_CYCLIC)
disparity.add_array("minSAD", 12290, 4, PARTITION_CYCLIC)
disparity.add_array("retDisp", 12290, 4, PARTITION_CYCLIC)
disparity.generate_separate_kernels(separate=True)
disparity.use_local_makefile()

localization = Benchmark("localization",
                         "localization/src/c/script_localization")
localization.set_kernels(["weightedSample_worker"])
localization.add_loop("weightedSample_worker", 20, 3)
localization.add_loop("weightedSample_worker", 22, 3)
localization.add_loop("weightedSample_worker", 27, 3)
localization.add_array("seed", 500, 4, PARTITION_CYCLIC)
localization.add_array("bin", 500, 4, PARTITION_CYCLIC)
localization.add_array("w", 500, 4, PARTITION_CYCLIC)
localization.use_local_makefile()

# Input size: sim
sift = Benchmark("sift", "sift/src/c/script_sift")
sift.set_kernels(["imsmooth_worker"])
sift.add_array("temp", 27, 4, PARTITION_CYCLIC)
# The sizes of these arrays change over the iterations, so I've specified the
# largest size observed.
sift.add_array("buffer", 64*64, 4, PARTITION_CYCLIC)
sift.add_array("array", 64*64, 4, PARTITION_CYCLIC)
sift.add_array("out", 64*64, 4, PARTITION_CYCLIC)
sift.add_loop("imsmooth_worker", 62, UNROLL_FLATTEN)
sift.add_loop("imsmooth_worker", 68, UNROLL_FLATTEN)
sift.add_loop("imsmooth_worker", 77, UNROLL_ONE)
sift.add_loop("imsmooth_worker", 79)
sift.add_loop("imsmooth_worker", 101, UNROLL_ONE)
sift.add_loop("imsmooth_worker", 103)
sift.use_local_makefile()

# for sqcif: srtdPnts: 1632, suppressR: 544, supId: 544, tempp: 1632, temps: 544 interestPnts: 1632
# for sim: srtdPnts: 27, suppressR: 9, supId: 9, tempp: 27, temps: 9 interestPnts: 27
stitch = Benchmark("stitch", "stitch/src/c/script_stitch")
stitch.set_kernels(["getANMS_worker"])
stitch.add_array("srtdPnts", 27, 4, PARTITION_CYCLIC)
stitch.add_array("suppressR", 9, 4, PARTITION_CYCLIC)
stitch.add_array("supId", 9, 4, PARTITION_CYCLIC)
stitch.add_array("tempp", 27, 4, PARTITION_CYCLIC)
stitch.add_array("temps", 9, 4, PARTITION_CYCLIC)
stitch.add_array("interestPnts", 27, 4, PARTITION_CYCLIC)
stitch.add_array("validCount", 1, 4, PARTITION_COMPLETE)
stitch.add_array("num_interest_pts", 1, 4, PARTITION_COMPLETE)
stitch.add_loop("getANMS_worker", 142)
stitch.add_loop("getANMS_worker", 163)
stitch.add_loop("getANMS_worker", 178)
stitch.add_loop("getANMS_worker", 201)
stitch.add_loop("getANMS_worker", 214)
stitch.use_local_makefile()

# Input size: sim_fast (16x16)
texture = Benchmark("texture_synthesis",
    "texture_synthesis/src/c/script_texture_synthesis")
texture.set_kernels(["create_candidates_worker"])
texture.add_array("result", 1026, 4, PARTITION_CYCLIC)
texture.add_array("target", 1026, 4, PARTITION_CYCLIC)
texture.add_array("atlas", 2048, 4, PARTITION_CYCLIC)
texture.add_array("xloopout", 64, 4, PARTITION_COMPLETE)
texture.add_array("yloopout", 64, 4, PARTITION_COMPLETE)
texture.add_array("candlistx", 13, 4, PARTITION_COMPLETE)
texture.add_array("candlisty", 13, 4, PARTITION_COMPLETE)
texture.add_loop("create_candidates_worker", 182, UNROLL_ONE)
texture.add_loop("create_candidates_worker", 184)
texture.add_loop("create_candidates_worker", 209)
texture.use_local_makefile()

# Input size: sim_fast
# Note: sim_fast produces a 650MB dynamic trace, which is still workable. The
# test input results in just 53 cycles of total accelerator execution.
svm = Benchmark("svm", "svm/src/c/script_svm")
svm.set_kernels(["cal_learned_func_smart", "polynomial_smart"])
svm.add_array("X", 5122, 4, PARTITION_CYCLIC)
svm.add_array("Y", 20, 4, PARTITION_COMPLETE)
svm.add_array("a", 20, 4, PARTITION_COMPLETE)
svm.add_loop("polynomial_smart", 47)
svm.add_loop("cal_learned_func_smart", 46)
svm.use_local_makefile()

# Input size: sim (48x48 = 2304, +2 for extra metadata = 2306).
# TODO: Some kernels use the same array names, but the required sizes are
# smaller, so I'm just going to not specify them for now. In the future, we may
# need to specify array names on a per kernel basis.
tracking = Benchmark("tracking", "tracking/src/c/script_tracking")
tracking.set_kernels(["imageBlur_worker2", "calcSobel_dY_worker2",
                      "calcSobel_dX_worker2", "imageResize_worker2"])
tracking.set_main_id(0x00000240)
tracking.set_kernel_id("imageBlur_worker2", 0x00000250)
tracking.set_kernel_id("imageResize_worker2", 0x00000260)
tracking.set_kernel_id("calcSobel_dX_worker2", 0x00000270)
tracking.set_kernel_id("calcSobel_dY_worker2", 0x00000280)
tracking.add_array("resize_kernel", 25, 4, PARTITION_COMPLETE)
tracking.add_array("blur_kernel", 25, 4, PARTITION_COMPLETE)
tracking.add_array("sobel_kernel", 9, 4, PARTITION_COMPLETE)
tracking.add_array("sobel_kernel1", 3, 4, PARTITION_COMPLETE)
tracking.add_array("sobel_kernel2", 3, 4, PARTITION_COMPLETE)
tracking.add_array("imageIn", 2306, 4, PARTITION_CYCLIC)
tracking.add_array("imageOut", 2306, 4, PARTITION_CYCLIC)
tracking.add_array("tempOut", 2306, 4, PARTITION_CYCLIC)
tracking.add_loop("imageBlur_worker2", 66, UNROLL_ONE)
tracking.add_loop("imageBlur_worker2", 67)
tracking.add_loop("imageBlur_worker2", 71, UNROLL_FLATTEN)
tracking.add_loop("imageBlur_worker2", 73, UNROLL_FLATTEN)
tracking.add_loop("imageResize_worker2", 70, UNROLL_ONE)
tracking.add_loop("imageResize_worker2", 71)
tracking.add_loop("imageResize_worker2", 75, UNROLL_FLATTEN)
tracking.add_loop("imageResize_worker2", 76, UNROLL_FLATTEN)
tracking.add_loop("calcSobel_dX_worker2", 67, UNROLL_ONE)
tracking.add_loop("calcSobel_dX_worker2", 68)
tracking.add_loop("calcSobel_dX_worker2", 71, UNROLL_FLATTEN)
tracking.add_loop("calcSobel_dX_worker2", 72, UNROLL_FLATTEN)
tracking.add_loop("calcSobel_dY_worker2", 67, UNROLL_ONE)
tracking.add_loop("calcSobel_dY_worker2", 68)
tracking.add_loop("calcSobel_dY_worker2", 71, UNROLL_FLATTEN)
tracking.add_loop("calcSobel_dY_worker2", 72, UNROLL_FLATTEN)
tracking.set_exec_cmd("%(source_dir)s/vision/benchmarks/tracking/src/c/tracking-gem5")
tracking.set_run_args("%(source_dir)s/vision/benchmarks/tracking/data/qcif")
tracking.generate_separate_kernels(separate=True)
tracking.use_local_makefile()

# Input size: test (18x24). Smallest available, yet it still generates a 4GB
# dynamic trace!
multi_ncut = Benchmark("multi_ncut", "multi_ncut/src/c/script_multi_ncut")
multi_ncut.set_kernels(["fSortIndices_worker"])
multi_ncut.add_array("in", 1606, 4, PARTITION_CYCLIC)
multi_ncut.add_array("ind", 1606, 4, PARTITION_CYCLIC)
multi_ncut.add_loop("fSortIndices_worker", 39, UNROLL_ONE)
multi_ncut.add_loop("fSortIndices_worker", 41)
multi_ncut.add_loop("fSortIndices_worker", 46)
multi_ncut.add_loop("fSortIndices_worker", 59, UNROLL_ONE)
multi_ncut.add_loop("fSortIndices_worker", 61)
multi_ncut.add_loop("fSortIndices_worker", 66)
multi_ncut.use_local_makefile()

# Input size: sim_fast (36x48)
# TODO: on mser, Aladdin's DDDG optimizations create a dependence cycle, which
# breaks tree height reduction. To run this benchmark, tree height reduction
# must be disabled. This bug must be fixed at a later time.
mser = Benchmark("mser", "mser/src/c/script_mser")
mser.set_kernels(["compute_extremal_regions_tree", "fit_ellipses"])
mser.add_array("pairs_pt", 3456, 4, PARTITION_CYCLIC)
mser.add_array("forest_pt", 6912, 4, PARTITION_CYCLIC)
mser.add_array("subs_pt", 9, 4, PARTITION_COMPLETE)
mser.add_array("nsubs_pt", 3, 4, PARTITION_COMPLETE)
mser.add_array("strides_pt", 1729, 4, PARTITION_CYCLIC)
mser.add_array("visited_pt", 1729, 4, PARTITION_CYCLIC)
mser.add_array("joins_pt", 1729, 4, PARTITION_CYCLIC)
mser.add_array("I_pt", 1730, 4, PARTITION_CYCLIC)
mser.add_array("regions_pt", 13824, 4, PARTITION_CYCLIC)
mser.add_array("rindex", 1, 4, PARTITION_COMPLETE)
mser.add_array("ner", 1, 4, PARTITION_COMPLETE)
mser.add_array("njoins", 1, 4, PARTITION_COMPLETE)
mser.add_array("dims", 3, 4, PARTITION_COMPLETE)
mser.add_array("acc_pt", 3458, 4, PARTITION_CYCLIC)
mser.add_array("ell_pt", 2, 4, PARTITION_COMPLETE)
mser.add_loop("compute_extremal_regions_tree", 335, UNROLL_ONE)
mser.add_loop("compute_extremal_regions_tree", 356, UNROLL_FLATTEN)
mser.add_loop("compute_extremal_regions_tree", 365)
mser.add_loop("compute_extremal_regions_tree", 373, UNROLL_FLATTEN)
mser.add_loop("compute_extremal_regions_tree", 405)
mser.add_loop("compute_extremal_regions_tree", 410)
mser.add_loop("compute_extremal_regions_tree", 418)
mser.add_loop("compute_extremal_regions_tree", 423)
mser.add_loop("compute_extremal_regions_tree", 508)
mser.add_loop("fit_ellipses", 723, UNROLL_ONE)
mser.add_loop("fit_ellipses", 727, UNROLL_FLATTEN)
mser.add_loop("fit_ellipses", 732)
mser.add_loop("fit_ellipses", 743)
mser.add_loop("fit_ellipses", 750)
mser.add_loop("fit_ellipses", 758)
mser.add_loop("fit_ellipses", 766)
mser.generate_separate_kernels(separate=True)
mser.use_local_makefile()

COMPLETE_CORTEXSUITE = [disparity, localization, sift, stitch, texture, svm,
                        tracking, multi_ncut, mser]
CORTEXSUITE = [tracking]
